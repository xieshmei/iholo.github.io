<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Commons Email组件的使用]]></title>
      <url>%2F2017%2F07%2F08%2F%E4%BD%BF%E7%94%A8Commons%20Email%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[介绍Apache Commons Eamil组件在Java mail的基础上进行了封装，简化了邮件的发送,它提供了几个类用于不同email类型的发送. 类 作用 SimpleEmail 用于简单邮件的发送 MultiPartEmail 包含附件类型的邮件 HtmlEmail HTML格式的文本邮件 ImageHtmlEmail 用于发送包含HTML模板的邮件 EmailAttachment 定义邮件附件 下载官网下载官网下载：Apache Commons Email 1.4 Maven123456&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; NOTE: Commons Email 依赖 javax.mail，javax.activation 示例SimpleEmail12345678910Email email = new SimpleEmail();email.setHostName(&quot;smtp.qq.com&quot;);email.setSmtpPort(465);email.setAuthentication(&quot;userName&quot;, &quot;passWord&quot;);email.setSSLOnConnect(true);email.setFrom(&quot;user@qq.com&quot;);email.setSubject(&quot;邮件主题&quot;);email.setMsg(&quot;邮件内容&quot;);email.addTo(&quot;foo@bar.com&quot;);email.send(); MultiPartEmailMultiPartEmail用于发送包含附件的邮件，其中附件使用EmailAttachment构建123456789101112131415EmailAttachment attachment = new EmailAttachment();attachment.setPath(&quot;D:\\Users\\1.txt&quot;);attachment.setName(&quot;照片&quot;);attachment.setDescription(&quot;附件描述&quot;);MultiPartEmail email = new MultiPartEmail();email.setHostName(HOST_NAME);email.setSmtpPort(SMTP_PORT);email.setAuthentication(USER_NAME, PASS_WORD);email.setFrom(&quot;user@qq.com&quot;);email.addTo(&quot;touser@gmail.com&quot;);email.setSubject(&quot;附件邮件测试&quot;);email.setMsg(&quot;正文测试&quot;);email.attach(attachment);String str=email.send(); HtmlEmailHtmlEmail 123456789101112131415161718HtmlEmail email = new HtmlEmail();email.setHostName("mail.myserver.com");email.addTo("jdoe@somewhere.org", "John Doe");email.setFrom("me@apache.org", "Me");email.setSubject("Test email with inline image");// embed the image and get the content idURL url = new URL("http://www.apache.org/images/asf_logo_wide.gif");String cid = email.embed(url, "Apache logo");// set the html messageemail.setHtmlMsg("&lt;html&gt;The apache logo - &lt;img src=\"cid:"+cid+"\"&gt;&lt;/html&gt;");// set the alternative messageemail.setTextMsg("Your email client does not support HTML messages");// send the emailemail.send(); ImageHtmlEmailImageHtmlEmail用于发送固定HTML模板的邮件12345678910111213141516171819202122// load your HTML email template String htmlEmailTemplate = ".... &lt;img src=\"http://www.apache.org/images/feather.gif\"&gt; ...."; // define you base URL to resolve relative resource locations URL url = new URL("http://www.apache.org"); // create the email message ImageHtmlEmail email = new ImageHtmlEmail(); email.setDataSourceResolver(new DataSourceUrlResolver(url)); email.setHostName("mail.myserver.com"); email.addTo("jdoe@somewhere.org", "John Doe"); email.setFrom("me@apache.org", "Me"); email.setSubject("Test email with inline image"); // set the html message email.setHtmlMsg(htmlEmailTemplate); // set the alternative message email.setTextMsg("Your email client does not support HTML messages"); // send the email email.send(); 参考:Commail Email官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>%2F2017%2F03%2F16%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 该方法的基本思想是： 先从数列中取出一个数作为基准数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法： 先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。以一个数组作为示例，取区间第一个数为基准数。 0 1 2 3 4 5 6 7 8 9 ==72 == 6 57 88 60 42 83 73 48 85 初始时，i = 0; j = 9; X = a[i] = 72 由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。 从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–; 0 1 2 3 4 5 6 7 8 9 ==48 == 6 57 88 60 42 83 73 88 85 i = 3; j = 7; X=72 再重复上面的步骤，先从后向前找，再从前向后找。 从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++; 从i开始向后找，当i=5时，由于i==j退出。 此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 0 1 2 3 4 5 6 7 8 9 ==48 == 6 57 42 60 72 83 73 88 85 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。 对挖坑填数进行总结 i =L; j = R; 将基准数挖出形成第一个坑a[i]。 j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 照着这个总结很容易实现挖坑填数的代码：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125; 再写分治法的代码：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125; 这样的代码显然不够简洁，对其组合整理下：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
