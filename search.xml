<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Linux下的tar压缩解压缩命令详解]]></title>
      <url>%2F2017%2F07%2F10%2FLinux%E4%B8%8B%E7%9A%84tar%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[tar12345-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的12345678910111213141516-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。# tar -cf all.tar *.jpg这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。# tar -rf all.tar *.gif这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。# tar -uf all.tar logo.gif这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。# tar -tf all.tar这条命令是列出all.tar包中所有文件，-t是列出文件的意思# tar -xf all.tar这条命令是解出all.tar包中所有文件，-t是解开的意思 压缩1234567891011tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg tar -czf jpg.tar.gz *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz tar -cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar -cZf jpg.tar.Z *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux 解压1234567891011tar -xvf file.tar //解压 tar包tar -xzvf file.tar.gz //解压tar.gztar -xjvf file.tar.bz2 //解压 tar.bz2tar -xZvf file.tar.Z //解压tar.Zunrar e file.rar //解压rarunzip file.zip //解压zip 总结12345678910111213141516171、*.tar 用 tar -xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、*.tar.gz和*.tgz 用 tar -xzf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar -xjf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar -xZf 解压8、*.rar 用 unrar e解压9、*.zip 用 unzip 解压 原文链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Commons Email组件的使用]]></title>
      <url>%2F2017%2F07%2F08%2F%E4%BD%BF%E7%94%A8Commons%20Email%20%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[介绍Apache Commons Eamil组件在Java mail的基础上进行了封装，简化了邮件的发送,它提供了几个类用于不同email类型的发送. 类 作用 SimpleEmail 用于简单邮件的发送 MultiPartEmail 包含附件类型的邮件 HtmlEmail HTML格式的文本邮件 ImageHtmlEmail 用于发送包含HTML模板的邮件 EmailAttachment 定义邮件附件 下载官网下载官网下载：Apache Commons Email 1.4 Maven123456&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-email --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; NOTE: Commons Email 依赖 javax.mail，javax.activation 示例SimpleEmail12345678910Email email = new SimpleEmail();email.setHostName(&quot;smtp.qq.com&quot;);email.setSmtpPort(465);email.setAuthentication(&quot;userName&quot;, &quot;passWord&quot;);email.setSSLOnConnect(true);email.setFrom(&quot;user@qq.com&quot;);email.setSubject(&quot;邮件主题&quot;);email.setMsg(&quot;邮件内容&quot;);email.addTo(&quot;foo@bar.com&quot;);email.send(); MultiPartEmailMultiPartEmail用于发送包含附件的邮件，其中附件使用EmailAttachment构建123456789101112131415EmailAttachment attachment = new EmailAttachment();attachment.setPath(&quot;D:\\Users\\1.txt&quot;);attachment.setName(&quot;照片&quot;);attachment.setDescription(&quot;附件描述&quot;);MultiPartEmail email = new MultiPartEmail();email.setHostName(HOST_NAME);email.setSmtpPort(SMTP_PORT);email.setAuthentication(USER_NAME, PASS_WORD);email.setFrom(&quot;user@qq.com&quot;);email.addTo(&quot;touser@gmail.com&quot;);email.setSubject(&quot;附件邮件测试&quot;);email.setMsg(&quot;正文测试&quot;);email.attach(attachment);String str=email.send(); HtmlEmailHtmlEmail 123456789101112131415161718HtmlEmail email = new HtmlEmail();email.setHostName("mail.myserver.com");email.addTo("jdoe@somewhere.org", "John Doe");email.setFrom("me@apache.org", "Me");email.setSubject("Test email with inline image");// embed the image and get the content idURL url = new URL("http://www.apache.org/images/asf_logo_wide.gif");String cid = email.embed(url, "Apache logo");// set the html messageemail.setHtmlMsg("&lt;html&gt;The apache logo - &lt;img src=\"cid:"+cid+"\"&gt;&lt;/html&gt;");// set the alternative messageemail.setTextMsg("Your email client does not support HTML messages");// send the emailemail.send(); ImageHtmlEmailImageHtmlEmail用于发送固定HTML模板的邮件12345678910111213141516171819202122// load your HTML email template String htmlEmailTemplate = ".... &lt;img src=\"http://www.apache.org/images/feather.gif\"&gt; ...."; // define you base URL to resolve relative resource locations URL url = new URL("http://www.apache.org"); // create the email message ImageHtmlEmail email = new ImageHtmlEmail(); email.setDataSourceResolver(new DataSourceUrlResolver(url)); email.setHostName("mail.myserver.com"); email.addTo("jdoe@somewhere.org", "John Doe"); email.setFrom("me@apache.org", "Me"); email.setSubject("Test email with inline image"); // set the html message email.setHtmlMsg(htmlEmailTemplate); // set the alternative message email.setTextMsg("Your email client does not support HTML messages"); // send the email email.send(); 参考:Commail Email官网]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>%2F2017%2F03%2F16%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 该方法的基本思想是： 先从数列中取出一个数作为基准数。 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。 再对左右区间重复第二步，直到各区间只有一个数。虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法： 先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助）。以一个数组作为示例，取区间第一个数为基准数。 0 1 2 3 4 5 6 7 8 9 ==72 == 6 57 88 60 42 83 73 48 85 初始时，i = 0; j = 9; X = a[i] = 72 由于已经将a[0]中的数保存到X中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。 从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–; 0 1 2 3 4 5 6 7 8 9 ==48 == 6 57 88 60 42 83 73 88 85 i = 3; j = 7; X=72 再重复上面的步骤，先从后向前找，再从前向后找。 从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++; 从i开始向后找，当i=5时，由于i==j退出。 此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 0 1 2 3 4 5 6 7 8 9 ==48 == 6 57 42 60 72 83 73 88 85 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。 对挖坑填数进行总结 i =L; j = R; 将基准数挖出形成第一个坑a[i]。 j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。 i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。 照着这个总结很容易实现挖坑填数的代码：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125; 再写分治法的代码：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125; 这样的代码显然不够简洁，对其组合整理下：123456789void quick_sort1(int s[], int l, int r)&#123; if (l &lt; r) &#123; int i = AdjustArray(s, l, r);//先成挖坑填数法调整s[] quick_sort1(s, l, i - 1); // 递归调用 quick_sort1(s, i + 1, r); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
